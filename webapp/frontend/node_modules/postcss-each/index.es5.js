'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _postcss = require('postcss');

var _postcss2 = _interopRequireDefault(_postcss);

var _postcssSimpleVars = require('postcss-simple-vars');

var _postcssSimpleVars2 = _interopRequireDefault(_postcssSimpleVars);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SEPARATOR = /\s+in\s+/;

function checkParams(params) {
  if (!SEPARATOR.test(params)) return 'Missed "in" keyword in @each';

  var _params$split$map = params.split(SEPARATOR).map(function (str) {
    return str.trim();
  });

  var _params$split$map2 = _slicedToArray(_params$split$map, 2);

  var name = _params$split$map2[0];
  var values = _params$split$map2[1];


  if (!name.match(/\$[_a-zA-Z]?\w+/)) return 'Missed variable name in @each';
  if (!values.match(/(\w+\,?\s?)+/)) return 'Missed values list in @each';

  return null;
}

function tokenize(str) {
  return _postcss2.default.list.comma(str).map(function (str) {
    return str.replace(/^\$/, '');
  });
}

function paramsList(params) {
  var _params$split$map3 = params.split(SEPARATOR).map(tokenize);

  var _params$split$map4 = _slicedToArray(_params$split$map3, 2);

  var vars = _params$split$map4[0];
  var values = _params$split$map4[1];

  var matched = false;

  values = values.map(function (value) {
    var match = value.match(/^\((.*)\)$/);
    if (match) matched = true;
    return match ? _postcss2.default.list.comma(match[1]) : value;
  });

  values = matched ? values : [values];

  return {
    names: values.map(function (_, i) {
      return vars[i];
    }),
    indexName: vars[values.length],
    values: values
  };
}

function processRules(rule, params) {
  params.values[0].forEach(function (_, i) {
    var vals = {};

    params.names.forEach(function (name, j) {
      vals[name] = params.values[j][i];
    });

    if (params.indexName) vals[params.indexName] = i;

    rule.nodes.forEach(function (node) {
      var clone = node.clone();
      var proxy = _postcss2.default.rule({ nodes: [clone] });

      (0, _postcssSimpleVars2.default)({ only: vals })(proxy);
      rule.parent.insertBefore(rule, clone);
    });
  });
}

function processEach(rule) {
  var params = ' ' + rule.params + ' ';
  var error = checkParams(params);
  if (error) throw rule.error(error);

  var parsedParams = paramsList(params);
  processRules(rule, parsedParams);
  rule.remove();
  processLoop(rule.root());
}

function rulesExists(css) {
  var rulesLength = 0;
  css.walkAtRules('each', function () {
    return rulesLength++;
  });
  return rulesLength;
}

function processLoop(css, opts) {
  var hasPlugins = opts && opts.plugins;

  if (hasPlugins && opts.plugins.afterEach && opts.plugins.afterEach.length) {
    css = (0, _postcss2.default)(opts.plugins.afterEach).process(css).root;
  }

  css.walkAtRules('each', processEach);

  if (hasPlugins && opts.plugins.beforeEach && opts.plugins.beforeEach.length) {
    css = (0, _postcss2.default)(opts.plugins.beforeEach).process(css).root;
  }

  if (rulesExists(css)) processLoop(css, opts);
};

exports.default = _postcss2.default.plugin('postcss-each', function (opts) {
  opts = opts || {};
  return function (css, result) {
    return processLoop(css, opts);
  };
});
module.exports = exports['default'];

